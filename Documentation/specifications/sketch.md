# Framework documentation

# Requirements

The front controller needs to:

- Get the HTTP request
- Pass the HTTP request to the kernel for it to be handled
- Produce an HTTP response

The kernel needs to:

- Get the controller hook mapped to the HTTP request
- Call the controller hook and pass the environment (i.e. server variables) to the controller
- Return to the caller the HTTP response generated by the controller

The controller needs to:

- Get the template to be rendered by the view
- Get the view that will render the templates
- Send back a response
- Get the model?


# Architecture

The main components like the Kernel and Router are designed as static classes that implement the Registry.

# Sequence of Operation

The following diagram represents the operation sequence of the framework:

```
                                  +---------------------------------------+
                                  | KERNEL                                |
                                  |                                       |
+--------+                        |    .------.             .--------.    |                          +--------+
| CLIENT |----- Http Request -------->| Handle |           | Dispatch |--------- Http Response ----->| CLIENT |
+--------+                        |    '--+---'             '--------'    |                          +--------+
                                  |       |                       ^       |
                                  |       |                       |       |
                                  +------ | --------------------- | ------+
                                          |                       |
                                          |                       |
                                       Request                Controller
                                    URI & method                  |
                                          |                       |
                                          |                       |
                                  +------ | --------------------- | ------+
                                  | ROUTER|                       |       |
                                  |       |                       |       |
                                  |       |    .--------------.   |       |
                                  |       '-->| Get Controller |--'       |
                                  |            '--------------'           |
                                  |                   ^                   |
                                  |                   |                   |
                                  |                   |                   |
                                  |              -----------              |
                                  |              Route Table              |
                                  |              -----------              |
                                  |                                       |
                                  +---------------------------------------+
```

## The app lives in an environment

The application lives in an environment. The natural task of an application is to provide a requested resource. To do this, the application must know what resource was requested so that it can respond.

## Useful error messages

A framework that reports errors like a compiler. Emitted errors should be useful. They should tell the developer what happened and how the error may be fixed. These errors should be emitted to a log. Do not return these errors reports to the client. The client must not knoww anything about the internal working of the application. Therefore, a standard error response shall be returned. It must say something to the likes of, "Something went wrong." But behind the scenes, the error log will contain details of the error.

## Route placeholder syntax

A placeholder has a syntax of a your typical identifier. It can only contain letters, numbers and an underscore, and must not begin with a number. The body of the identifier is preceded by a colon. I stole this concept from the Slim framework.

### Syntax specification in EBNF:

```
placeholder =
    ":" id ;
```

## Template specifier syntax

To specify a template, I use a syntax that tells the framework what template
to use and where the template is located. I stole this concept from Laravel.

A template specifier has the name of the template and can be preceded by the
names of the subdirectories in which the template is located. When specifying
a template, the template name is stated plainly. However, if the template is
located in subdirectories below the template directory, then the names of the
subdirectories are specified and separated by the '.' (dot) character.

*Example 1: A template file located at the root of template directory*

A file located at `/app/template/404.php` takes the specifier form of `404`.
Its view maybe instantiated as: `new View('404')`;

*Example 2: A template file located in a subdirectory of the root of the
template directory.*

A file located at `/app/template/error/404.php` takes the specifier form of
`error.404`. Notice that the template specifier mirrors the location of the
template file. The view for this template may be instantiated as:
`new View('Error.404')`;

## Syntax specification in EBNF:

```
view_decl =
    {directory "."} view ;

view =
    id;

directory =
    id;
```

## Components

**How do components relate to each other?**

### Concept

The framework is broken down into components. The purpose of a component lies in decoupling (loose coupling) and reusability.

A *component* is made up of models, interfaces, abstracts, and subcomponents. Components have purpose. Their goal is to provide their purpose.

A *subcomponent* is like a component, only difference is this: It's parent is a component. Subcomponents can nest in other subcomponents. Subcomponents are structured in hierarchy: Think of a diamond: at the top are the main components that handle program logic; then lower are subcomponents that handle utility tasks. These utilities are put to use by the main components to accomplish the purpose of component.

A *model* is a representation of an entity or concept. A model can be anything.

### Convention

Components are represented by folders and model, interfaces, abstracts are presented as class files.

Example

```
\Octagon\Routing                     // Component (folder)
\Octagon\Routing\Route.php           // Model
\Octagon\Routing\RouteInterface.php  // Interface
\Octagon\Routing\AbstractRoute.php   // Abstract
\Octagon\Routing\Linker              // Subcomponent (folder)
```
